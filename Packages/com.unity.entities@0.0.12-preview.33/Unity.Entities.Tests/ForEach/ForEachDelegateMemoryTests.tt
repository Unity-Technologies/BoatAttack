<#/*THIS IS A T4 FILE - see t4_text_templating.md for what it is and how to run codegen*/#>
<#@ assembly name="System.Collections" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".gen.cs" #>
#if !UNITY_DOTSPLAYER
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by ForEachDelegateMemoryTests.tt

using NUnit.Framework;

/*
The purpose of these tests is to validate and make invariant assumptions about
compiler codegen. ForEach needs to receive a delegate, and there are many ways
to implicitly construct one, which are tested below. What we want is to ensure
that we understand the scenarios that generate garbage every frame so we can
detect and warn about them in user code, or replace with our own codegen.

There are two paths to garbage:

1.  ForEach needs to receive a delegate to do its work, which is represented in
    the runtime as a MulticastDelegate. This needs to be allocated from the
    gc, and it is not done statically, but on-demand.

    The result of this `newobj` may always be cached manually, and sometimes is
    cached automatically. That's one of the things the below tests validate.

2.  In a closure, something needs to associate all captured non-global
    variables (including `this`) with the delegate, typically a codegen'd class
    with captures as members. This will involve a gc alloc per-call.

    Note that local functions use a struct for their captures when called in
    the containing method, but this optimization does not apply if the local is
    converted to a delegate.

Categories: (each has a fixture)

    Lambda: Using the () => {} syntax. Current C# compilers (at least Mono and
    Roslyn) will

    This is the key scenario we care about,
    because it's the most natural to use with ForEach. (The other scenarios we
    include because users may adopt them as workarounds.)

    LocalFunction: Using a local function defined in the same function where the
    ForEach is called.

    (Static)Method: An ordinary (static) class method. Aside from lack of access
    to locals (and `this` for statics), these should behave identically to local
    functions.

    "Cached": Because the compilers don't currently cache delegates auto-created
    for anything except lambdas, we'll generate garbage every frame for all
    operations. So we manually cache in order to test just the closure alloc
    behavior.

Tests: (some combos that are impossible are left out)

    Empty: just an empty code block

    WithLocal: a closure that captures a local

    WithThis: a closure that captures `this`

    WithStatic: a method that uses a static
*/

namespace Unity.Entities.Tests.ForEach
{
<#
const int k_Loops = 5;

foreach (var fixture in new[] {
    // spec: bool allocEveryCall, int firstCallTotal, int loopedCallTotal
    // invoke: 0 = test.name, 1 = test.code
    (type: "Lambda", invoke: "v => {1}",
        empty:  new Spec(false, 0,  0),
        local:  new Spec( true, 4, 20),
        thiz:   new Spec( true, 5, 15),
        statik: new Spec(false, 6, 16)),
    (type: "LocalFunction", invoke: "{0}",
        empty:  new Spec(false, 0,  0) { Disabled = "Unstable" },
        local:  new Spec( true, 0,  0) { Disabled = "Unstable" },
        thiz:   new Spec( true, 5, 15),
        statik: new Spec( true, 6, 16) { Disabled = "Unstable" }),  // << loopedCallAllocCount doesn't match expected
    (type: "LocalFunctionCached", invoke: "m_{0}Delegate = m_{0}Delegate ?? {0}",
        empty:  new Spec(false, 0,  0),
        local:  null, // new Spec( true, 0, 0),
        thiz:   new Spec(false, 5, 15),
        statik: new Spec(false, 6, 16)),
    (type: "Method", invoke: "Method{0}",
        empty:  new Spec( true, 0,  0),
        local:  null,
        thiz:   new Spec( true, 5, 15),
        statik: new Spec( true, 6, 16)),
    (type: "MethodCached", invoke: "m_{0}Delegate = m_{0}Delegate ?? Method{0}",
        empty:  new Spec(false, 0,  0),
        local:  null,
        thiz:   new Spec(false, 5, 15),
        statik: new Spec(false, 6, 16)),
    (type: "StaticMethod", invoke: "StaticMethod{0}",
        empty:  new Spec( true, 0,  0),
        local:  null,
        thiz:   null,
        statik: new Spec( true, 6, 16)),
    (type: "StaticMethodCached", invoke: "m_{0}Delegate = m_{0}Delegate ?? StaticMethod{0}",
        empty:  new Spec(false, 0,  0),
        local:  null,
        thiz:   null,
        statik: new Spec(false, 6, 16)) }) {

    // TODO: fix unstable commented-out Spec stuff above

    var tests = new[] {
        (name: "Empty",      spec: fixture.empty,  code: "{ }", retval: "0"),
        (name: "WithLocal",  spec: fixture.local,  code: "{ local += v; }",    retval: "local"),
        (name: "WithThis",   spec: fixture.thiz,   code: "{ m_Field += v; }",  retval: "m_Field"),
        (name: "WithStatic", spec: fixture.statik, code: "{ s_Static += v; }", retval: "s_Static") };
#>
    class ForEach<#=fixture.type#>MemoryTests : ForEachMemoryTestFixtureBase
    {
<#
    foreach (var test in tests) {
        if (test.spec == null)
            continue;
        string member = null;
        if (fixture.type.StartsWith("Method"))
            member = $"void Method{test.name}(int v) {test.code}";
        else if (fixture.type.StartsWith("StaticMethod"))
            member = $"static void StaticMethod{test.name}(int v) {test.code}";
        if (fixture.type.EndsWith("Cached")) {#>
        TestDelegate m_<#=test.name#>Delegate;
<#      }
        if (member != null) {#>
        <#=member#>

<#      }#>
        int Invoke<#=test.name#>()
        {
<#      if (test.name == "WithLocal") {#>
            int local = 2;
<#      }#>
<#      if (fixture.type.StartsWith("LocalFunction")) {#>
            void <#=test.name#>(int v) <#=test.code#>
<#      }#>
            TestInvoke(<#=string.Format(fixture.invoke, test.name, test.code)#>);
            return <#=test.retval#>;
        }

        [Test]
<#      if (test.spec.Disabled != null) {#>
        [Ignore("<#=test.spec.Disabled#>")]
<#      }#>
        public void <#=test.name#>_ShouldAlloc<#=test.spec.AllocEveryCall ? "EveryCall" : "FirstCallOnly"#>()
        {
            AllocRecorder.enabled = true;
            var firstCallTotal = Invoke<#=test.name#>();
            AllocRecorder.enabled = false;
            var firstCallAllocCount = AllocRecorder.sampleBlockCount;

            AllocRecorder.enabled = true;
            var loopedCallTotal = 0;
            for (var i = 0; i < <#=k_Loops#>; ++i)
                loopedCallTotal <#=test.name == "WithLocal" ? "+=" : "="#> Invoke<#=test.name#>();
            AllocRecorder.enabled = false;
            var loopedCallAllocCount = AllocRecorder.sampleBlockCount;

            Assert.Greater(firstCallAllocCount, 0);
<#      if (test.spec.AllocEveryCall) {#>
            Assert.AreEqual(firstCallAllocCount * <#=k_Loops#>, loopedCallAllocCount);
<#      } else {#>
            Assert.Zero(loopedCallAllocCount);
<#      }#>

            Assert.AreEqual(<#=test.spec.FirstCallTotal#>, firstCallTotal);
            Assert.AreEqual(<#=test.spec.LoopedCallTotal#>, loopedCallTotal);
        }

<#  }#>
    }

<#}#>
}
#endif // !UNITY_DOTSPLAYER
<#+

class Spec
{
    public bool AllocEveryCall;

    // these counts are just used to validate that the delegates are called the expected number of times
    public int FirstCallTotal;
    public int LoopedCallTotal;

    public string Disabled;

    public Spec(bool allocEveryCall, int firstCallTotal, int loopedCallTotal)
    {
        AllocEveryCall = allocEveryCall;
        FirstCallTotal = firstCallTotal;
        LoopedCallTotal = loopedCallTotal;
    }
}

#>
