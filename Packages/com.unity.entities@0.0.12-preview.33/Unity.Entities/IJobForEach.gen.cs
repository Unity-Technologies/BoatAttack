//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
// Generated by T4 (TextTransform.exe) from the file IJobForEach.tt
//

using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;

namespace Unity.Entities
{

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_C<,>))]
	#endif
	public interface IJobForEach<T0> : IJobForEach_C<T0>
		where T0 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EC<,>))]
	#endif
	public interface IJobForEachWithEntity<T0> : IJobForEachWithEntity_EC<T0>
		where T0 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CC<,,>))]
	#endif
	public interface IJobForEach<T0, T1> : IJobForEach_CC<T0, T1>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECC<,,>))]
	#endif
	public interface IJobForEachWithEntity<T0, T1> : IJobForEachWithEntity_ECC<T0, T1>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCC<,,,>))]
	#endif
	public interface IJobForEach<T0, T1, T2> : IJobForEach_CCC<T0, T1, T2>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCC<,,,>))]
	#endif
	public interface IJobForEachWithEntity<T0, T1, T2> : IJobForEachWithEntity_ECCC<T0, T1, T2>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCC<,,,,>))]
	#endif
	public interface IJobForEach<T0, T1, T2, T3> : IJobForEach_CCCC<T0, T1, T2, T3>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCC<,,,,>))]
	#endif
	public interface IJobForEachWithEntity<T0, T1, T2, T3> : IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCC<,,,,,>))]
	#endif
	public interface IJobForEach<T0, T1, T2, T3, T4> : IJobForEach_CCCCC<T0, T1, T2, T3, T4>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCC<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity<T0, T1, T2, T3, T4> : IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCCC<,,,,,,>))]
	#endif
	public interface IJobForEach<T0, T1, T2, T3, T4, T5> : IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{}

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCCC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity<T0, T1, T2, T3, T4, T5> : IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{}


#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_C<,>))]
	#endif
	public interface IJobForEach_C<T0> : JobForEachExtensions.IBaseJobForEach_C
		where T0 : struct, IComponentData
	{
        void Execute(ref T0 c0);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EC<,>))]
	#endif
	public interface IJobForEachWithEntity_EC<T0> : JobForEachExtensions.IBaseJobForEach_EC
		where T0 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_B<,>))]
	#endif
	public interface IJobForEach_B<T0> : JobForEachExtensions.IBaseJobForEach_B
		where T0 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EB<,>))]
	#endif
	public interface IJobForEachWithEntity_EB<T0> : JobForEachExtensions.IBaseJobForEach_EB
		where T0 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CC<,,>))]
	#endif
	public interface IJobForEach_CC<T0, T1> : JobForEachExtensions.IBaseJobForEach_CC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECC<,,>))]
	#endif
	public interface IJobForEachWithEntity_ECC<T0, T1> : JobForEachExtensions.IBaseJobForEach_ECC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BC<,,>))]
	#endif
	public interface IJobForEach_BC<T0, T1> : JobForEachExtensions.IBaseJobForEach_BC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBC<,,>))]
	#endif
	public interface IJobForEachWithEntity_EBC<T0, T1> : JobForEachExtensions.IBaseJobForEach_EBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BB<,,>))]
	#endif
	public interface IJobForEach_BB<T0, T1> : JobForEachExtensions.IBaseJobForEach_BB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBB<,,>))]
	#endif
	public interface IJobForEachWithEntity_EBB<T0, T1> : JobForEachExtensions.IBaseJobForEach_EBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCC<,,,>))]
	#endif
	public interface IJobForEach_CCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_CCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCC<,,,>))]
	#endif
	public interface IJobForEachWithEntity_ECCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_ECCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCC<,,,>))]
	#endif
	public interface IJobForEach_BCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_BCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCC<,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBCC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_EBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBC<,,,>))]
	#endif
	public interface IJobForEach_BBC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_BBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBC<,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBC<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_EBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBB<,,,>))]
	#endif
	public interface IJobForEach_BBB<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_BBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBB<,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBB<T0, T1, T2> : JobForEachExtensions.IBaseJobForEach_EBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCC<,,,,>))]
	#endif
	public interface IJobForEach_CCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_CCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCC<,,,,>))]
	#endif
	public interface IJobForEachWithEntity_ECCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_ECCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCCC<,,,,>))]
	#endif
	public interface IJobForEach_BCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCCC<,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBCCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBCC<,,,,>))]
	#endif
	public interface IJobForEach_BBCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBCC<,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBCC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBC<,,,,>))]
	#endif
	public interface IJobForEach_BBBC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBC<,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBC<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBB<,,,,>))]
	#endif
	public interface IJobForEach_BBBB<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_BBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBB<,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBB<T0, T1, T2, T3> : JobForEachExtensions.IBaseJobForEach_EBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCC<,,,,,>))]
	#endif
	public interface IJobForEach_CCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_CCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCC<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_ECCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCCCC<,,,,,>))]
	#endif
	public interface IJobForEach_BCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCCCC<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBCCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBCCC<,,,,,>))]
	#endif
	public interface IJobForEach_BBCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBCCC<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBCCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBCC<,,,,,>))]
	#endif
	public interface IJobForEach_BBBCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBCC<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBCC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBC<,,,,,>))]
	#endif
	public interface IJobForEach_BBBBC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBC<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBBC<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBB<,,,,,>))]
	#endif
	public interface IJobForEach_BBBBB<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_BBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBB<,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBBB<T0, T1, T2, T3, T4> : JobForEachExtensions.IBaseJobForEach_EBBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_CCCCCC<,,,,,,>))]
	#endif
	public interface IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_CCCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_ECCCCCC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_ECCCCCC
		where T0 : struct, IComponentData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, ref T0 c0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BCCCCC<,,,,,,>))]
	#endif
	public interface IJobForEach_BCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BCCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBCCCCC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBCCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBCCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IComponentData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, ref T1 c1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBCCCC<,,,,,,>))]
	#endif
	public interface IJobForEach_BBCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBCCCC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBCCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBCCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IComponentData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, ref T2 c2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBCCC<,,,,,,>))]
	#endif
	public interface IJobForEach_BBBCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBCCC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBCCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBCCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IComponentData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, ref T3 c3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBCC<,,,,,,>))]
	#endif
	public interface IJobForEach_BBBBCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBCC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBBCC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBBCC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IComponentData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, ref T4 c4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBBC<,,,,,,>))]
	#endif
	public interface IJobForEach_BBBBBC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IComponentData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBBC<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBBBC<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBBBC
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IComponentData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, ref T5 c5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_BBBBBB<,,,,,,>))]
	#endif
	public interface IJobForEach_BBBBBB<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_BBBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IBufferElementData
	{
        void Execute(DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5);
    }

#if !UNITY_ZEROPLAYER
	[JobProducerType(typeof(JobForEachExtensions.JobStruct_Process_EBBBBBB<,,,,,,>))]
	#endif
	public interface IJobForEachWithEntity_EBBBBBB<T0, T1, T2, T3, T4, T5> : JobForEachExtensions.IBaseJobForEach_EBBBBBB
		where T0 : struct, IBufferElementData
		where T1 : struct, IBufferElementData
		where T2 : struct, IBufferElementData
		where T3 : struct, IBufferElementData
		where T4 : struct, IBufferElementData
		where T5 : struct, IBufferElementData
	{
        void Execute(Entity entity, int index, DynamicBuffer<T0> b0, DynamicBuffer<T1> b1, DynamicBuffer<T2> b2, DynamicBuffer<T3> b3, DynamicBuffer<T4> b4, DynamicBuffer<T5> b5);
    }


    public static partial class JobForEachExtensions
    {
#if !UNITY_DOTSPLAYER
        public static JobHandle Schedule<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle ScheduleSingle<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle Run<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_DOTSPLAYER
        public static JobHandle Schedule<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, null, query, 1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle ScheduleSingle<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Batched);
            throw new System.ArgumentException("Not supported");
        }
#endif
#if !UNITY_DOTSPLAYER
        public static JobHandle Run<T>(this T jobData, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where T : struct, IBaseJobForEach
        {
            var typeT = typeof(T);
            if (typeof(IBaseJobForEach_C).IsAssignableFrom(typeT))
                return ScheduleInternal_C(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EC).IsAssignableFrom(typeT))
                return ScheduleInternal_EC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_B).IsAssignableFrom(typeT))
                return ScheduleInternal_B(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EB).IsAssignableFrom(typeT))
                return ScheduleInternal_EB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CC).IsAssignableFrom(typeT))
                return ScheduleInternal_CC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BC).IsAssignableFrom(typeT))
                return ScheduleInternal_BC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BB).IsAssignableFrom(typeT))
                return ScheduleInternal_BB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_CCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_CCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_ECCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_ECCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBCCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBCCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBCCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBCCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBCCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBCCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBCC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBCC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBC).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBC(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_BBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_BBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            if (typeof(IBaseJobForEach_EBBBBBB).IsAssignableFrom(typeT))
                return ScheduleInternal_EBBBBBB(ref jobData, null, query, -1, dependsOn, ScheduleMode.Run);
            throw new System.ArgumentException("Not supported");
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_C<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_C<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_C<,>), isParallelFor, ref JobStruct_ProcessInfer_C<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_C<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_C<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_C : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_C<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_C<T, T0>
            where T : struct, IJobForEach_C<T0>
			where T0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_C<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_C<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_C<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_C<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EC<,>), isParallelFor, ref JobStruct_ProcessInfer_EC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EC<T, T0>
            where T : struct, IJobForEachWithEntity_EC<T0>
			where T0 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EC<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EC<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EC<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EC<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_B<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_B<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_B<,>), isParallelFor, ref JobStruct_ProcessInfer_B<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_B<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_B<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_B : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_B<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_B<T, T0>
            where T : struct, IJobForEach_B<T0>
			where T0 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_B<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_B<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_B<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_B<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EB<,>), isParallelFor, ref JobStruct_ProcessInfer_EB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EB<T, T0>
            where T : struct, IJobForEachWithEntity_EB<T0>
			where T0 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EB<T, T0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EB<T, T0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EB<T, T0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EB<T, T0> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CC<,,>), isParallelFor, ref JobStruct_ProcessInfer_CC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CC<T, T0, T1>
            where T : struct, IJobForEach_CC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECC<,,>), isParallelFor, ref JobStruct_ProcessInfer_ECC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECC<T, T0, T1>
            where T : struct, IJobForEachWithEntity_ECC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BC<,,>), isParallelFor, ref JobStruct_ProcessInfer_BC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BC<T, T0, T1>
            where T : struct, IJobForEach_BC<T0, T1>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBC<,,>), isParallelFor, ref JobStruct_ProcessInfer_EBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBC<T, T0, T1>
            where T : struct, IJobForEachWithEntity_EBC<T0, T1>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBC<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBC<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBC<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBC<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BB<,,>), isParallelFor, ref JobStruct_ProcessInfer_BB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BB<T, T0, T1>
            where T : struct, IJobForEach_BB<T0, T1>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BB<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BB<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BB<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BB<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBB<,,>), isParallelFor, ref JobStruct_ProcessInfer_EBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBB<T, T0, T1>
            where T : struct, IJobForEachWithEntity_EBB<T0, T1>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBB<T, T0, T1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBB<T, T0, T1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBB<T, T0, T1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBB<T, T0, T1> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCC<T, T0, T1, T2>
            where T : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCC<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCC<T, T0, T1, T2>
            where T : struct, IJobForEach_BCC<T0, T1, T2>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCC<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_EBCC<T0, T1, T2>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBC<T, T0, T1, T2>
            where T : struct, IJobForEach_BBC<T0, T1, T2>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBC<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBC<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_EBBC<T0, T1, T2>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBC<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBC<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBC<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBC<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBB<,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBB<T, T0, T1, T2>
            where T : struct, IJobForEach_BBB<T0, T1, T2>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBB<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBB<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBB<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBB<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBB<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBB<T, T0, T1, T2>
            where T : struct, IJobForEachWithEntity_EBBB<T0, T1, T2>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBB<T, T0, T1, T2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBB<T, T0, T1, T2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBB<T, T0, T1, T2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBB<T, T0, T1, T2> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BCCC<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBCCC<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BBCC<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBCC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBCC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBBCC<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBCC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBCC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBCC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBCC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBC<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BBBC<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBC<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBC<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBBBC<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBC<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBC<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBC<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBC<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBB<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBB<T, T0, T1, T2, T3>
            where T : struct, IJobForEach_BBBB<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBB<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBB<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBB<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBB<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBB<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBB<T, T0, T1, T2, T3>
            where T : struct, IJobForEachWithEntity_EBBBB<T0, T1, T2, T3>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBB<T, T0, T1, T2, T3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBB<T, T0, T1, T2, T3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBB<T, T0, T1, T2, T3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBB<T, T0, T1, T2, T3> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBCCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBCCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBBCC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBCC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBBCC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBCC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBBBC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBC<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBBBC<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBC<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBB<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEach_BBBBB<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety4, jobData.Iterator.m_BufferSafety4);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBB<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4>
            where T : struct, IJobForEachWithEntity_EBBBBB<T0, T1, T2, T3, T4>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBB<T, T0, T1, T2, T3, T4> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety4, jobData.Iterator.m_BufferSafety4);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_CCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_CCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_CCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_CCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_CCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_CCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_CCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_CCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_CCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_ECCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_ECCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_ECCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_ECCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_ECCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_ECCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_ECCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_ECCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_ECCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
					var ptr0 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion));
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<T0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBCCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBCCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBCCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBCCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBCCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBCCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBCCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBCCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBCCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr1 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion));
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], ref UnsafeUtilityEx.ArrayElementAsRef<T1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBCCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBCCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBCCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBCCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBCCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBCCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBCCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBCCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBCCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr2 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion));
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], ref UnsafeUtilityEx.ArrayElementAsRef<T2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBCCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBCCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBCCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBCCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBCCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBCCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBCCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBCCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBCCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr3 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion));
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], ref UnsafeUtilityEx.ArrayElementAsRef<T3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBBCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBCC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBCC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBCC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBCC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBCC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBCC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBCC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBCC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBBCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBCC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr4 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion));
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], ref UnsafeUtilityEx.ArrayElementAsRef<T4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBBC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBBBC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IBufferElementData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety4, jobData.Iterator.m_BufferSafety4);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBBC<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBBC<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBBC<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBBC<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBBC<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBBC<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBBC : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBBC<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBBBC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IBufferElementData
			where T5 : struct, IComponentData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBBC<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety4, jobData.Iterator.m_BufferSafety4);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
#endif
					var ptr5 = UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion));


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], ref UnsafeUtilityEx.ArrayElementAsRef<T5>(ptr5, i));
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_BBBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_BBBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_BBBBBB<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_BBBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_BBBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_BBBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_BBBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_BBBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEach_BBBBBB<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IBufferElementData
			where T5 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_BBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety4, jobData.Iterator.m_BufferSafety4);
					var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety5, jobData.Iterator.m_BufferSafety5);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
					var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], buffer5[i]);
                    }
                }
            }
        }
#endif

#if !UNITY_DOTSPLAYER
        internal static unsafe JobHandle ScheduleInternal_EBBBBBB<T>(ref T jobData, ComponentSystemBase system, EntityQuery query, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
            where T : struct
        {
            JobStruct_ProcessInfer_EBBBBBB<T> fullData;
            fullData.Data = jobData;

            var isParallelFor = innerloopBatchCount != -1;
            Initialize(system, query, typeof(T), typeof(JobStruct_Process_EBBBBBB<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EBBBBBB<T>.Cache, out fullData.Iterator);

            var unfilteredChunkCount = fullData.Iterator.m_Length;
            var iterator = JobStruct_ProcessInfer_EBBBBBB<T>.Cache.EntityQuery.GetComponentChunkIterator();

            var prefilterHandle = ComponentChunkIterator.PreparePrefilteredChunkLists(unfilteredChunkCount, iterator.m_MatchingArchetypeList, iterator.m_Filter, dependsOn, mode, out fullData.PrefilterData, out var deferredCountData);

            return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.PrefilterData, fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, iterator.RequiresFilter(), ref JobStruct_ProcessInfer_EBBBBBB<T>.Cache, deferredCountData, prefilterHandle, mode);
        }
#endif

        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public interface IBaseJobForEach_EBBBBBB : IBaseJobForEach {}

#if !UNITY_DOTSPLAYER
        [StructLayout(LayoutKind.Sequential)]
        private struct JobStruct_ProcessInfer_EBBBBBB<T> where T : struct
        {
            public static JobForEachCache Cache;

            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal struct JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5>
            where T : struct, IJobForEachWithEntity_EBBBBBB<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IBufferElementData
			where T1 : struct, IBufferElementData
			where T2 : struct, IBufferElementData
			where T3 : struct, IBufferElementData
			where T4 : struct, IBufferElementData
			where T5 : struct, IBufferElementData
        {
            public ProcessIterationData Iterator;
            public T Data;

            [DeallocateOnJobCompletion]
            [NativeDisableContainerSafetyRestriction]
            public NativeArray<byte> PrefilterData;

            [Preserve]
            public static IntPtr Initialize(JobType jobType)
            {
                return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
            }

            delegate void ExecuteJobFunction(ref JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

            public static unsafe void Execute(ref JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
            {
                ComponentChunkIterator.UnpackPrefilterData(jobData.PrefilterData, out var chunks, out var entityIndices, out var chunkCount);

                if (jobData.Iterator.m_IsParallelFor)
                {
                    int begin, end;
                    while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                        ExecuteChunk(ref jobData, bufferRangePatchData, begin, end, chunks, entityIndices);
                }
                else
                {
                    ExecuteChunk(ref jobData, bufferRangePatchData, 0, chunkCount, chunks, entityIndices);
                }
            }

            static unsafe void ExecuteChunk(ref JobStruct_Process_EBBBBBB<T, T0, T1, T2, T3, T4, T5> jobData, IntPtr bufferRangePatchData, int begin, int end, ArchetypeChunk* chunks, int* entityIndices)
            {
				var typeLookupCache0 = 0;
				var typeLookupCache1 = 0;
				var typeLookupCache2 = 0;
				var typeLookupCache3 = 0;
				var typeLookupCache4 = 0;
				var typeLookupCache5 = 0;

                for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                {
                    var chunk = chunks[blockIndex];
                    int beginIndex = entityIndices[blockIndex];
                    var count = chunk.Count;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
                    JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, beginIndex + count);
#endif
		          var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(ComponentChunkIterator.GetChunkComponentDataPtr(chunk.m_Chunk, false, 0, jobData.Iterator.GlobalSystemVersion));
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex0, ref typeLookupCache0);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex1, ref typeLookupCache1);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex2, ref typeLookupCache2);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex3, ref typeLookupCache3);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex4, ref typeLookupCache4);
					ChunkDataUtility.GetIndexInTypeArray(chunk.m_Chunk->Archetype, jobData.Iterator.TypeIndex5, ref typeLookupCache5);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety0, jobData.Iterator.m_BufferSafety0);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety1, jobData.Iterator.m_BufferSafety1);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety2, jobData.Iterator.m_BufferSafety2);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety3, jobData.Iterator.m_BufferSafety3);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety4, jobData.Iterator.m_BufferSafety4);
					var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion, jobData.Iterator.m_Safety5, jobData.Iterator.m_BufferSafety5);
#else
					var buffer0 = ComponentChunkIterator.GetChunkBufferAccessor<T0>(chunk.m_Chunk, jobData.Iterator.IsReadOnly0 == 0, typeLookupCache0, jobData.Iterator.GlobalSystemVersion);
					var buffer1 = ComponentChunkIterator.GetChunkBufferAccessor<T1>(chunk.m_Chunk, jobData.Iterator.IsReadOnly1 == 0, typeLookupCache1, jobData.Iterator.GlobalSystemVersion);
					var buffer2 = ComponentChunkIterator.GetChunkBufferAccessor<T2>(chunk.m_Chunk, jobData.Iterator.IsReadOnly2 == 0, typeLookupCache2, jobData.Iterator.GlobalSystemVersion);
					var buffer3 = ComponentChunkIterator.GetChunkBufferAccessor<T3>(chunk.m_Chunk, jobData.Iterator.IsReadOnly3 == 0, typeLookupCache3, jobData.Iterator.GlobalSystemVersion);
					var buffer4 = ComponentChunkIterator.GetChunkBufferAccessor<T4>(chunk.m_Chunk, jobData.Iterator.IsReadOnly4 == 0, typeLookupCache4, jobData.Iterator.GlobalSystemVersion);
					var buffer5 = ComponentChunkIterator.GetChunkBufferAccessor<T5>(chunk.m_Chunk, jobData.Iterator.IsReadOnly5 == 0, typeLookupCache5, jobData.Iterator.GlobalSystemVersion);
#endif


                    for (var i = 0; i != count; i++)
                    {
                        jobData.Data.Execute(ptrE[i], i + beginIndex, buffer0[i], buffer1[i], buffer2[i], buffer3[i], buffer4[i], buffer5[i]);
                    }
                }
            }
        }
#endif


#if UNITY_DOTSPLAYER
        internal unsafe static JobHandle Schedule_Query_rD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_C<T0>
			where T0 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_C<T0>
			where T0 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_EC<T0>
			where T0 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwD<TJob, T0>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_EC<T0>
			where T0 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwD<TJob, T0, T1>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECC<T0, T1>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwD<TJob, T0, T1, T2>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCC<T0, T1, T2>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwD<TJob, T0, T1, T2, T3>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCC<T0, T1, T2, T3>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDrD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDwD<TJob, T0, T1, T2, T3, T4>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCC<T0, T1, T2, T3, T4>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_rDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_wDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEach_CCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDrDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDwDrD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(true);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafeReadOnlyPtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDrDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(true);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafeReadOnlyPtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDrDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(true);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafeReadOnlyPtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDrDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(true);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafeReadOnlyPtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDrDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(true);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafeReadOnlyPtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_ErDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(true);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafeReadOnlyPtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

        internal unsafe static JobHandle Schedule_Query_EwDwDwDwDwDwD<TJob, T0, T1, T2, T3, T4, T5>(this TJob job, EntityQuery query, JobHandle dependsOn = default(JobHandle))
            where TJob : struct, IJobForEachWithEntity_ECCCCCC<T0, T1, T2, T3, T4, T5>
			where T0 : struct, IComponentData
			where T1 : struct, IComponentData
			where T2 : struct, IComponentData
			where T3 : struct, IComponentData
			where T4 : struct, IComponentData
			where T5 : struct, IComponentData
        {
            ArchetypeChunkEntityType entityType = World.Active.EntityManager.GetArchetypeChunkEntityType();
            ArchetypeChunkComponentType<T0> chunkComponentType0 = World.Active.EntityManager.GetArchetypeChunkComponentType<T0>(false);
            ArchetypeChunkComponentType<T1> chunkComponentType1 = World.Active.EntityManager.GetArchetypeChunkComponentType<T1>(false);
            ArchetypeChunkComponentType<T2> chunkComponentType2 = World.Active.EntityManager.GetArchetypeChunkComponentType<T2>(false);
            ArchetypeChunkComponentType<T3> chunkComponentType3 = World.Active.EntityManager.GetArchetypeChunkComponentType<T3>(false);
            ArchetypeChunkComponentType<T4> chunkComponentType4 = World.Active.EntityManager.GetArchetypeChunkComponentType<T4>(false);
            ArchetypeChunkComponentType<T5> chunkComponentType5 = World.Active.EntityManager.GetArchetypeChunkComponentType<T5>(false);

            using (var chunks = query.CreateArchetypeChunkArray(Allocator.TempJob))
            {
                foreach (var chunk in chunks)
                {
                    var entityArray = (Entity*)chunk.GetNativeArray(entityType).GetUnsafeReadOnlyPtr();
                    var array0 = chunk.GetNativeArray(chunkComponentType0).GetUnsafePtr();
                    var array1 = chunk.GetNativeArray(chunkComponentType1).GetUnsafePtr();
                    var array2 = chunk.GetNativeArray(chunkComponentType2).GetUnsafePtr();
                    var array3 = chunk.GetNativeArray(chunkComponentType3).GetUnsafePtr();
                    var array4 = chunk.GetNativeArray(chunkComponentType4).GetUnsafePtr();
                    var array5 = chunk.GetNativeArray(chunkComponentType5).GetUnsafePtr();
                    for (int i = 0, count = chunk.Count; i < count; ++i)
                        job.Execute(
                            entityArray[i], entityArray[i].Index,
                            ref UnsafeUtilityEx.ArrayElementAsRef<T0>(array0, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T1>(array1, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T2>(array2, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T3>(array3, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T4>(array4, i),
                            ref UnsafeUtilityEx.ArrayElementAsRef<T5>(array5, i)
                        );
                }
            }
            DoDeallocateOnJobCompletion(job);
            return new JobHandle();
        }

#endif
    }
}

